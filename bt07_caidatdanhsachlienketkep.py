# -*- coding: utf-8 -*-
"""BT07_CaiDatDanhSachLienKetKep

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yca9VhpdatUy0xIaRIbTOgyFXmtxYnfw
"""

class Node: 
  
    # Hàm tạo để tạo một nút mới
    def __init__(self, data): 
        self.data = data 
        self.next = None
        self.prev = None
  
# Lớp tạo danh sách được liên kết kép
class DoublyLinkedList: 
  
    # Hàm tạo cho Danh sách được Liên kết Đôi rỗng
    def __init__(self): 
        self.head = None
  
   # Đưa ra một tham chiếu đến đầu danh sách và 
  # số nguyên, chèn một nút mới vào đầu danh sách 
    def push(self, new_data): 
  
       # 1. Phân bổ nút.
       # 2. Đặt dữ liệu vào đó. 
        new_node = Node(new_data) 
  
        # 3. Thực hiện tiếp theo của nút mới làm đầu và trước đó là Không có (đã Không có)
        new_node.next = self.head 
  
        # 4. thay đổi trước của nút đầu thành new_node
        if self.head is not None: 
            self.head.prev = new_node 
  
        # 5.di chuyển đầu để trỏ đến nút mới
        self.head = new_node 
  
    # Với một nút như prev_node, chèn một nút mới sau nút cho trước
    def insertAfter(self, prev_node, new_data): 
  
        # 1. Kiểm tra xem giá trị trước đó có phải là Không
        if prev_node is None: 
            print ("the given previous node cannot be NULL")
            return 
  
        # 2. phân bổ nút mới
        # 3. đưa vào dữ liệu
        new_node = Node(new_data) 
  
        # 4. Tạo mạng của nút mới như nút tiếp theo của nút trước
        new_node.next = prev_node.next
  
        # 5.Đặt prev_node như trước của new_node
        prev_node.next = new_node 
  
        # 6.Đặt prev_node như trước của new_node
        new_node.prev = prev_node 
  
        # 7. Thay đổi trước của nút tiếp theo của new_nodes
        if new_node.next is not None: 
            new_node.next.prev = new_node 
  
    
    def append(self, new_data): 
  
       
        new_node = Node(new_data) 
  
        #Nút mới này sẽ là nút cuối cùng,
        #vì vậy hãy làm cho nó tiếp theo là Không có
        new_node.next = None
  
        #  Nếu Danh sách được Liên kết trống, thì hãy tạo
        # nút mới với nút đứng đầu
        if self.head is None: 
            new_node.prev = None
            self.head = new_node 
            return 
  
        # Đi qua cho đến nút cuối cùng 
        last = self.head 
        while(last.next is not None): 
            last = last.next
  
        # Thay đổi nút tiếp theo của nút cuối cùng
        last.next = new_node 
  
        # Đặt nút cuối cùng làm nút trước của nút mới
        new_node.prev = last 
  
        return
  
    # Hàm này in nội dung của danh sách liên kết
     # bắt đầu từ nút đã cho 
    def printList(self, node): 
  
        print ("\nTraversal in forward direction")#Truyền theo hướng về phía trước
        while(node is not None): 
            print (" % d" %(node.data), )
            last = node 
            node = node.next
  
        print ("\nTraversal in reverse direction")#Truyền theo hướng ngược lại
        while(last is not None): 
            print (" % d" %(last.data), )
            last = last.prev

# Chương trình điều khiển để kiểm tra các chức năng trên
  
# Bắt đầu với danh sách trống 
llist = DoublyLinkedList() 
  
# Chèn 6. Vì vậy, danh sách trở thành 6-> Không có
llist.append(6) 
  
# Chèn 7 ở đầu.
# Vì vậy, danh sách được liên kết trở thành 7-> 6-> Không có 
llist.push(7) 
  
# Chèn 1 ở đầu.
# Vì vậy, danh sách được liên kết trở thành 1-> 7-> 6-> Không có
llist.push(1) 
  
# Chèn 4 ở cuối.
# Vì vậy, danh sách được liên kết trở thành 1-> 7-> 6-> 4-> Không có  
llist.append(4) 
  
# Chèn 8, sau 7.
# Vì vậy, danh sách được liên kết trở thành 1-> 7-> 8-> 6-> 4-> Không có 
llist.insertAfter(llist.head.next, 8) 
  

llist.printList(llist.head)